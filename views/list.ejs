<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>My Watchlist</title>
    <!-- Link to your main CSS file (assuming it's in public/css/style.css) -->
    <link href="/list.css" rel="stylesheet" />
    <!-- Google Fonts CDN for Inter -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <!-- Assuming you have a partials/header.ejs. If not, include the navbar directly here. -->
    <nav class="navbar">
      <div class="nav-container">
        <a href="/" class="nav-link">Home</a>
        <a href="/search" class="nav-link">Search Movies</a>
        <a href="/user/list" class="nav-link">My Watchlist</a>
        <a href="/about" class="nav-link">About</a>
        <a href="/contact" class="nav-link">Contact</a>
        <a href="/faq" class="nav-link">FAQ</a>
        <a href="/user/profile" class="nav-link">Profile</a>
      </div>
    </nav>

    <div class="container">
      <h1>My Watchlist</h1>

      <div id="loadingIndicator" class="loading-indicator">
        Loading your watchlist...
      </div>

      <div id="authPrompt" class="auth-prompt hidden">
        <h2>Unlock Your Personalized Watchlist!</h2>
        <p>
          Sign up or log in to save your favorite movies and access them
          anytime, anywhere.
        </p>
        <div class="auth-links">
          <a href="/user/register">Sign Up</a>
          <a href="/user/login">Log In</a>
        </div>
      </div>

      <div id="watchlistControls" class="watchlist-controls hidden">
        <div class="control-group">
          <label for="sortSelect">Sort By:</label>
          <select id="sortSelect" class="control-select">
            <option value="added_at_desc">Date Added (Newest First)</option>
            <option value="added_at_asc">Date Added (Oldest First)</option>
            <option value="release_date_desc">Release Date (Newest First)</option>
            <option value="release_date_asc">Release Date (Oldest First)</option>
            <option value="title_asc">Title (A-Z)</option>
            <option value="title_desc">Title (Z-A)</option>
          </select>
        </div>

        <div class="control-group">
          <label for="filterStatusAndTypeSelect">Filter:</label>
          <select id="filterStatusAndTypeSelect" class="control-select">
            <option value="all">All</option>
            <option value="status:Plan to Watch">Plan to Watch</option>
            <option value="status:Watching">Watching</option>
            <option value="status:Completed">Completed</option>
            <option value="status:On Hold">On Hold</option>
            <option value="status:Dropped">Dropped</option>
            <option value="type:movie">Movies Only</option>
            <option value="type:series">Series Only</soption>
            <option value="isManual:true">Manually Added Only</option>
          </select>
        </div>

        <button id="addBySearchBtn" class="btn btn-primary">
          <a
            href="/search"
            style="
              text-decoration: none;
              color: inherit;
              display: block;
              padding: 0;
            "
            >Search</a
          >
        </button>

        <button id="addManuallyBtn" class="btn btn-primary">
          Add Manually
        </button>
        
        <!-- NEW: Download Filtered List Button -->
        <button id="downloadListBtn" class="btn btn-secondary">
          Download Filtered List
        </button>

        <!-- NEW: Upload List Button and Hidden File Input -->
        <button id="uploadListBtn" class="btn btn-secondary">
          Upload List
        </button>
        <input type="file" id="fileInput" accept=".txt" class="hidden" style="display: none;">

        <select id="bulkStatusSelect" class="control-select hidden">
          <option value="">Change Status Of Selected To...</option>
          <option value="Plan to Watch">Plan to Watch</option>
          <option value="Watching">Watching</option>
          <option value="Completed">Completed</option>
          <option value="On Hold">On Hold</option>
          <option value="Dropped">Dropped</option>
        </select>
        <button id="applyBulkStatusButton" class="btn btn-secondary hidden">Apply Status</button>
        <button id="bulkRemoveButton" class="btn btn-danger hidden">
          Remove Selected
        </button>
      </div>

      <div id="watchlistContent" class="movie-list-container hidden"></div>

      <div id="noMoviesMessage" class="no-content-message hidden">
        <p>Your watchlist is empty! Start adding movies from the
        <a href="/search">Search Movies</a> page.</p>
      </div>
    </div>

    <div id="messageBox" class="message-box hidden">
      <div class="header">
        <h3 id="messageTitle"></h3>
        <button id="closeMessageBox" class="close-button">&times;</button>
      </div>
      <p id="messageContent"></p>
    </div>

    <div
      id="manualAddModal"
      class="modal"
      style="
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.4);
      "
    >
      <div
        class="modal-content"
        style="
          background-color: #fefefe;
          margin: 15% auto;
          padding: 20px;
          border: 1px solid #888;
          width: 80%;
          max-width: 500px;
          border-radius: 8px;
          position: relative;
        "
      >
        <span
          class="close-button"
          style="
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
          "
          >&times;</span
        >
        <h2>Add Movie Manually</h2>
        <form id="manualAddForm">
          <div class="form-group" style="margin-bottom: 15px">
            <label
              for="manualMovieName"
              style="display: block; margin-bottom: 5px"
              >Movie Name:</label
            >
            <input
              type="text"
              id="manualMovieName"
              name="title"
              required
              class="form-control"
              style="
                width: 100%;
                padding: 8px;
                box-sizing: border-box;
                border: 1px solid #ccc;
                border-radius: 4px;
              "
            />
          </div>
          <div class="form-group" style="margin-bottom: 15px">
            <label
              for="manualMovieYear"
              style="display: block; margin-bottom: 5px"
              >Year (Optional):</label
            >
            <input
              type="number"
              id="manualMovieYear"
              name="year"
              min="1800"
              max="<%= new Date().getFullYear() + 5 %>"
              class="form-control"
              style="
                width: 100%;
                padding: 8px;
                box-sizing: border-box;
                border: 1px solid #ccc;
                border-radius: 4px;
              "
            />
          </div>
          <div class="form-group" style="margin-bottom: 15px">
            <label for="manualMovieDescription">Description (Optional):</label>
            <textarea
              id="manualMovieDescription"
              rows="4"
              placeholder="Enter a brief description of the movie or series."
              class="form-control"
              style="
                width: 100%;
                padding: 8px;
                box-sizing: border-box;
                border: 1px solid #ccc;
                border-radius: 4px;
              "
            ></textarea>
          </div>

          <div class="form-group" style="margin-bottom: 15px">
            <label
              for="manualMovieStatus"
              style="display: block; margin-bottom: 5px"
              >Status:</label
            >
            <select
              id="manualMovieStatus"
              class="form-control"
              style="
                width: 100%;
                padding: 8px;
                box-sizing: border-box;
                border: 1px solid #ccc;
                border-radius: 4px;
              "
            >
              <option value="Plan to Watch">Plan to Watch</option>
              <option value="Watching">Watching</option>
              <option value="Completed">Completed</option>
              <option value="On Hold">On Hold</option>
              <option value="Dropped">Dropped</option>
            </select>
          </div>

          <div class="form-group" style="margin-bottom: 15px">
            <label
              for="manualMovieType"
              style="display: block; margin-bottom: 5px"
              >Type:</label
            >
            <select
              id="manualMovieType"
              class="form-control"
              style="
                width: 100%;
                padding: 8px;
                box-sizing: border-box;
                border: 1px solid #ccc;
                border-radius: 4px;
              "
            >
              <option value="movie">Movie</option>
              <option value="series">Series</option>
            </select>
          </div>

          <div class="form-group" style="margin-bottom: 15px">
            <label
              for="manualMovieGenre"
              style="display: block; margin-bottom: 5px"
              >Genres (comma-separated, optional):</label
            >
            <input
              type="text"
              id="manualMovieGenre"
              name="genre"
              placeholder="e.g., Action, Sci-Fi, Drama"
              class="form-control"
              style="
                width: 100%;
                padding: 8px;
                box-sizing: border-box;
                border: 1px solid #ccc;
                border-radius: 4px;
              "
            />
          </div>
          <button
            type="submit"
            class="btn btn-success"
            style="
              padding: 10px 15px;
              border: none;
              border-radius: 5px;
              background-color: #28a745;
              color: white;
              cursor: pointer;
            "
          >
            Add Movie
          </button>
          <p id="manualAddMessage" style="margin-top: 10px; color: green"></p>
        </form>
      </div>
    </div>

    <!-- Assuming you have a partials/footer.ejs. If not, include the footer directly here. -->
    <!-- <%- include('partials/footer') %> -->

    <script type="module">
        // Import Firebase services
        import {
            initializeApp,
            getApps,
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";
        import {
            getAuth,
            onAuthStateChanged,
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import {
            getFirestore,
            collection,
            query,
            // where, // Not explicitly used in the main fetch query
            getDocs,
            // orderBy, // Removed from query, client-side sorting is used
            deleteDoc,
            doc,
            updateDoc,
            Timestamp, // Import Timestamp for serverTimestamp() equivalent
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        console.log("list.ejs script loaded.");

        // Your web app's Firebase configuration (from server injection)
        const firebaseConfig = JSON.parse('<%- firebaseConfig || "{}" %>');
        let app;
        let analytics;
        let db;
        let auth;
        let userId = null;
        let isAuthReady = false;
        let appId = `<%- __app_id || 'default-app-id' %>`;

        let allWatchlistMovies = []; // Stores the full list of movies fetched from Firestore
        let displayedMovies = []; // Stores the currently filtered and sorted movies for rendering/download
        let selectedMovieIds = new Set(); // Stores IDs of selected movies for bulk actions

        // --- DOM elements (Declare all here, after global variables) ---
        const sortSelect = document.getElementById("sortSelect");
        const filterStatusAndTypeSelect = document.getElementById("filterStatusAndTypeSelect");
        const downloadListBtn = document.getElementById("downloadListBtn");
        const uploadListBtn = document.getElementById("uploadListBtn");
        const fileInput = document.getElementById("fileInput");

        const loadingIndicator = document.getElementById("loadingIndicator");
        const authPrompt = document.getElementById("authPrompt");
        const watchlistContent = document.getElementById("watchlistContent");
        const noMoviesMessage = document.getElementById("noMoviesMessage");
        const messageBox = document.getElementById("messageBox");
        const messageTitle = document.getElementById("messageTitle");
        const messageContent = document.getElementById("messageContent");
        const closeMessageBox = document.getElementById("closeMessageBox");

        const watchlistControls = document.getElementById("watchlistControls");
        const bulkStatusSelect = document.getElementById("bulkStatusSelect");
        const applyBulkStatusButton = document.getElementById("applyBulkStatusButton");
        const bulkRemoveButton = document.getElementById("bulkRemoveButton");

        // Manual Add Modal DOM elements
        const addManuallyBtn = document.getElementById("addManuallyBtn");
        const manualAddModal = document.getElementById("manualAddModal");
        const manualAddForm = document.getElementById("manualAddForm");
        const manualAddMessage = document.getElementById("manualAddMessage");
        const manualMovieDescription = document.getElementById("manualMovieDescription");
        const manualMovieName = document.getElementById("manualMovieName");
        const manualMovieYear = document.getElementById("manualMovieYear");
        const manualMovieStatus = document.getElementById("manualMovieStatus");
        const manualMovieType = document.getElementById("manualMovieType");
        const manualMovieGenre = document.getElementById("manualMovieGenre");

        // Function to show a custom message box (with optional confirmation)
        function showMessageBox(title, message, isConfirm = false, onConfirm = null) {
            if (messageBox && messageTitle && messageContent) {
                messageTitle.textContent = title;
                messageContent.textContent = message;
                messageBox.classList.add("show");

                // Clear previous buttons
                const existingButtons = messageBox.querySelectorAll('.message-box-buttons button');
                existingButtons.forEach(btn => btn.remove());

                if (isConfirm && onConfirm) {
                    const confirmButton = document.createElement('button');
                    confirmButton.textContent = 'Confirm';
                    confirmButton.classList.add('btn', 'btn-danger'); // Use appropriate styling
                    confirmButton.style.marginRight = '10px';
                    confirmButton.addEventListener('click', () => {
                        onConfirm();
                        hideMessageBox();
                    });

                    const cancelButton = document.createElement('button');
                    cancelButton.textContent = 'Cancel';
                    cancelButton.classList.add('btn', 'btn-secondary');
                    cancelButton.addEventListener('click', () => {
                        hideMessageBox();
                    });

                    const buttonContainer = document.createElement('div');
                    buttonContainer.classList.add('message-box-buttons');
                    buttonContainer.style.marginTop = '20px';
                    buttonContainer.appendChild(confirmButton);
                    buttonContainer.appendChild(cancelButton);
                    messageBox.appendChild(buttonContainer);
                }
            } else {
                console.error("Message box elements not found:", title, message);
                alert(`${title}\n\n${message}`); // Fallback to alert
            }
        }

        // Function to hide the custom message box
        function hideMessageBox() {
            if (messageBox) {
                messageBox.classList.remove("show");
            }
        }

        // Function to update visibility of bulk action buttons
        function updateBulkActionVisibility() {
            if (selectedMovieIds.size > 0) {
                bulkStatusSelect.classList.remove("hidden");
                applyBulkStatusButton.classList.remove("hidden");
                bulkRemoveButton.classList.remove("hidden");
            } else {
                bulkStatusSelect.classList.add("hidden");
                applyBulkStatusButton.classList.add("hidden");
                bulkRemoveButton.classList.add("hidden");
                bulkStatusSelect.value = ""; // Reset dropdown
            }
        }

        // Function to render movie cards
        function renderWatchlistMovies(moviesToRender) {
            watchlistContent.innerHTML = ""; // Clear current display
            if (moviesToRender.length === 0) {
                watchlistContent.classList.add("hidden"); // Hide content if empty
                return;
            }

            watchlistContent.classList.remove("hidden"); // Show content if movies exist

            moviesToRender.forEach((movie) => {
                const movieCard = document.createElement("div");
                movieCard.classList.add("movie-card");
                if (selectedMovieIds.has(movie.id)) {
                    movieCard.classList.add("selected");
                }

                const checkboxContainer = document.createElement("div");
                checkboxContainer.classList.add("checkbox-container");
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.value = movie.id;
                checkbox.checked = selectedMovieIds.has(movie.id);
                checkbox.addEventListener("change", (event) => {
                    if (event.target.checked) {
                        selectedMovieIds.add(movie.id);
                        movieCard.classList.add("selected");
                    } else {
                        selectedMovieIds.delete(movie.id);
                        movieCard.classList.remove("selected");
                    }
                    updateBulkActionVisibility();
                });
                checkboxContainer.appendChild(checkbox);
                movieCard.appendChild(checkboxContainer);

                const statusBadge = document.createElement("span");
                statusBadge.classList.add("status-badge");
                statusBadge.classList.add(
                    movie.status
                        ? movie.status.toLowerCase().replace(/\s/g, "-")
                        : "plan-to-watch"
                );
                statusBadge.textContent = movie.status || "Plan to Watch";
                movieCard.appendChild(statusBadge);

                const cardLink = document.createElement("a");
                cardLink.href = `/movie/${movie.id}`;
                cardLink.classList.add("card-link");
                cardLink.style.textDecoration = "none";
                cardLink.style.color = "inherit";
                cardLink.style.display = "block";
                cardLink.style.height = "100%";

                const poster = document.createElement("img");
                poster.alt = movie.title;
                poster.classList.add("poster-image");
                if (movie.isManual) {
                    poster.src = "/images/your_logo_filename.png"; // Use your actual default logo path
                    poster.classList.add("custom-manual-poster");
                } else if (movie.poster_path) {
                    poster.src = `https://image.tmdb.org/t/p/w500${movie.poster_path}`;
                } else {
                    poster.src = "/images/your_logo_filename.png"; // Fallback for TMDB movies with no poster
                }
                poster.onerror = function () {
                    this.onerror = null;
                    this.src = "/images/your_logo_filename.png";
                };

                const movieInfoSummary = document.createElement("div");
                movieInfoSummary.classList.add("movie-info-summary");

                const titleElement = document.createElement("h2");
                titleElement.textContent = movie.title;

                const displayYear = movie.year
                    ? movie.year
                    : movie.release_date
                        ? new Date(movie.release_date).getFullYear()
                        : "N/A";
                const releaseYearElement = document.createElement("p");
                releaseYearElement.classList.add("release-year");
                releaseYearElement.textContent = `Year: ${displayYear}`;

                const overviewOverlay = document.createElement("div");
                overviewOverlay.classList.add("movie-overview-overlay");
                const overviewText = document.createElement("p");
                overviewText.textContent =
                    movie.overview || "No description available.";
                overviewOverlay.appendChild(overviewText);

                movieInfoSummary.appendChild(titleElement);
                movieInfoSummary.appendChild(releaseYearElement);

                cardLink.appendChild(poster);
                cardLink.appendChild(movieInfoSummary);
                cardLink.appendChild(overviewOverlay);

                movieCard.appendChild(cardLink);
                watchlistContent.appendChild(movieCard);
            });
            updateBulkActionVisibility();
        }

        // Function to sort movies
        function sortMovies(movies, sortBy) {
            return [...movies].sort((a, b) => {
                let valA, valB;

                switch (sortBy) {
                    case "added_at_desc":
                        valA = a.added_at ? a.added_at.toDate() : new Date(0);
                        valB = b.added_at ? b.added_at.toDate() : new Date(0);
                        return valB.getTime() - valA.getTime();
                    case "added_at_asc":
                        valA = a.added_at ? a.added_at.toDate() : new Date(0);
                        valB = b.added_at ? b.added_at.toDate() : new Date(0);
                        return valA.getTime() - valB.getTime();
                    case "release_date_desc":
                        valA = a.year
                            ? a.year
                            : a.release_date
                                ? new Date(a.release_date).getFullYear()
                                : 0;
                        valB = b.year
                            ? b.year
                            : b.release_date
                                ? new Date(b.release_date).getFullYear()
                                : 0;
                        return valB - valA;
                    case "release_date_asc":
                        valA = a.year
                            ? a.year
                            : a.release_date
                                ? new Date(a.release_date).getFullYear()
                                : 0;
                        valB = b.year
                            ? b.year
                            : b.release_date
                                ? new Date(b.release_date).getFullYear()
                                : 0;
                        return valA - valB;
                    case "title_asc":
                        valA = a.title.toLowerCase();
                        valB = b.title.toLowerCase();
                        return valA.localeCompare(valB);
                    case "title_desc":
                        valA = a.title.toLowerCase();
                        valB = b.title.toLowerCase();
                        return valB.localeCompare(valA);
                    default:
                        return 0;
                }
            });
        }

        // Consolidated function to apply both filtering and sorting, then render
        function applySortAndFilter() {
            const currentSort = sortSelect.value;
            const currentFilter = filterStatusAndTypeSelect.value;

            let moviesToProcess = [...allWatchlistMovies];

            if (currentFilter !== "all") {
                const [filterType, filterValue] = currentFilter.split(":");

                moviesToProcess = moviesToProcess.filter(movie => {
                    if (filterType === "status") {
                        return (movie.status || "Plan to Watch") === filterValue;
                    } else if (filterType === "type") {
                        if (filterValue === "movie") {
                            return (movie.media_type === 'movie' || (!movie.isManual && !movie.media_type) || (movie.isManual && movie.type === 'movie'));
                        } else if (filterValue === "series") {
                            return (movie.media_type === 'tv' || (movie.isManual && movie.type === 'series'));
                        }
                    } else if (filterType === "isManual" && filterValue === "true") {
                        return movie.isManual === true;
                    }
                    return false;
                });
            }

            displayedMovies = sortMovies(moviesToProcess, currentSort); // Update the global displayedMovies
            renderWatchlistMovies(displayedMovies);

            // Show/hide no movies message based on filtered results
            if (displayedMovies.length === 0 && allWatchlistMovies.length > 0) {
                noMoviesMessage.classList.remove("hidden");
                noMoviesMessage.querySelector("p").textContent = "No movies match your current filter and sort criteria.";
                watchlistContent.classList.add("hidden"); // Hide movie grid
            } else if (allWatchlistMovies.length === 0) {
                noMoviesMessage.classList.remove("hidden");
                noMoviesMessage.querySelector("p").textContent = "Your watchlist is empty! Start by adding some movies!";
                watchlistContent.classList.add("hidden"); // Hide movie grid
            } else {
                noMoviesMessage.classList.add("hidden");
                watchlistContent.classList.remove("hidden"); // Show movie grid
            }
        }

        // NEW: Function to generate plain text list from displayed movies
        function generatePlainTextList(movies) {
            if (movies.length === 0) {
                return "Your watchlist is currently empty or no movies match the applied filters and sort criteria.\n";
            }

            let text = `My Watchlist - Filtered & Sorted List\n`;
            text += `Generated on: ${new Date().toLocaleString()}\n`;
            text += `Current Filter: ${filterStatusAndTypeSelect.options[filterStatusAndTypeSelect.selectedIndex].text}\n`;
            text += `Current Sort: ${sortSelect.options[sortSelect.selectedIndex].text}\n`;
            text += `----------------------------------------\n\n`;

            movies.forEach((movie, index) => {
                const title = movie.title || "N/A";
                const year = movie.year || (movie.release_date ? new Date(movie.release_date).getFullYear() : "N/A");
                const status = movie.status || "Plan to Watch";
                const type = movie.type || (movie.isManual ? "Manual Entry" : (movie.media_type === 'tv' ? 'Series' : 'Movie'));
                const genres = movie.genres && movie.genres.length > 0 ? movie.genres.join(", ") : "N/A";
                const overview = movie.overview || "No description available.";

                text += `${index + 1}. Title: ${title}\n`;
                text += `   Year: ${year}\n`;
                text += `   Status: ${status}\n`;
                text += `   Type: ${type}\n`;
                text += `   Genre(s): ${genres}\n`;
                text += `   Overview: ${overview.substring(0, 150)}${overview.length > 150 ? '...' : ''}\n`; // Truncate long overviews
                text += `----------------------------------------\n`;
            });

            return text;
        }

        // NEW: Function to trigger text file download
        function downloadTextFile(text, filename) {
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a); // Append to body is necessary for Firefox
            a.click();
            document.body.removeChild(a); // Clean up
            URL.revokeObjectURL(url); // Free up memory
        }

        // NEW: Function to parse plain text list into movie objects
        function parsePlainTextList(text) {
            const movies = [];
            const movieBlocks = text.split('----------------------------------------\n').slice(1);

            movieBlocks.forEach(block => {
                if (block.trim() === '') return;

                const lines = block.split('\n').map(line => line.trim()).filter(line => line !== '');
                const movie = {};

                lines.forEach(line => {
                    if (line.startsWith('Title:')) {
                        movie.title = line.substring('Title:'.length).trim();
                    } else if (line.startsWith('Year:')) {
                        const yearStr = line.substring('Year:'.length).trim();
                        movie.year = yearStr !== 'N/A' ? parseInt(yearStr, 10) : null;
                    } else if (line.startsWith('Status:')) {
                        movie.status = line.substring('Status:'.length).trim();
                    } else if (line.startsWith('Type:')) {
                        movie.type = line.substring('Type:'.length).trim();
                        if (movie.type === "Manual Entry") {
                            movie.isManual = true;
                            movie.type = movie.type || 'movie';
                        }
                    } else if (line.startsWith('Genre(s):')) {
                        const genresStr = line.substring('Genre(s):'.length).trim();
                        movie.genres = genresStr !== 'N/A' ? genresStr.split(',').map(g => g.trim()) : [];
                    } else if (line.startsWith('Overview:')) {
                        movie.overview = line.substring('Overview:'.length).trim();
                    }
                });

                movie.status = movie.status || "Plan to Watch";
                movie.type = movie.type || "movie";
                movie.genres = movie.genres || [];
                movie.overview = movie.overview || "No description available.";
                movie.isManual = movie.isManual || false;
                movie.poster_path = movie.poster_path || null;
                movie.media_type = movie.media_type || (movie.type === 'series' ? 'tv' : 'movie');

                if (movie.year && !movie.release_date) {
                    movie.release_date = `${movie.year}-01-01`;
                }

                if (movie.title) {
                    movies.push(movie);
                }
            });
            return movies;
        }

        // NEW: Function to upload movies to watchlist, checking for duplicates
        async function uploadMoviesToWatchlist(moviesToUpload) {
            if (!userId) {
                showMessageBox("Authentication Required", "Please log in to upload movies to your watchlist.");
                return;
            }

            loadingIndicator.classList.remove("hidden");
            let addedCount = 0;
            let skippedCount = 0;
            const currentAppId = appId;
            const currentUserId = userId;
            const watchlistCollectionRef = collection(db, `artifacts/${currentAppId}/users/${currentUserId}/watchlist`);

            try {
                const existingMoviesSnapshot = await getDocs(watchlistCollectionRef);
                const existingMovieTitles = new Set();
                existingMoviesSnapshot.forEach(doc => {
                    const data = doc.data();
                    existingMovieTitles.add(`${data.title || ''}-${data.year || ''}`.toLowerCase());
                });

                const idToken = await auth.currentUser.getIdToken();

                for (const movieData of moviesToUpload) {
                    const uniqueKey = `${movieData.title || ''}-${movieData.year || ''}`.toLowerCase();

                    if (existingMovieTitles.has(uniqueKey)) {
                        skippedCount++;
                        console.log(`Skipping duplicate: ${movieData.title} (${movieData.year})`);
                        continue;
                    }

                    const movieToAdd = {
                        ...movieData,
                        added_at: Timestamp.now(),
                    };

                    const response = await fetch("/movies/add-manual", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "Authorization": `Bearer ${idToken}`
                        },
                        body: JSON.stringify(movieToAdd),
                    });

                    if (response.ok) {
                        addedCount++;
                        existingMovieTitles.add(uniqueKey);
                    } else {
                        const errorResult = await response.json();
                        console.error(`Failed to add ${movieData.title}:`, errorResult.message);
                    }
                }

                showMessageBox(
                    "Upload Complete",
                    `Successfully added ${addedCount} new movie(s) and skipped ${skippedCount} existing movie(s).`
                );
                await fetchAndDisplayWatchlist();
            } catch (error) {
                console.error("Error during upload process:", error);
                showMessageBox("Upload Error", `Failed to upload list: ${error.message}`);
            } finally {
                loadingIndicator.classList.add("hidden");
            }
        }

        // Function to fetch and display watchlist
        async function fetchAndDisplayWatchlist() {
            console.log("fetchAndDisplayWatchlist called. isAuthReady:", isAuthReady, "db:", !!db, "userId:", userId);
            loadingIndicator.classList.remove("hidden");
            authPrompt.classList.add("hidden");
            watchlistContent.classList.add("hidden");
            noMoviesMessage.classList.add("hidden");
            watchlistControls.classList.add("hidden");
            watchlistContent.innerHTML = "";
            selectedMovieIds.clear();
            updateBulkActionVisibility();

            // Wait until Firebase Auth and Firestore are initialized and ready
            await new Promise((resolve) => {
                const checkReadyInterval = setInterval(() => {
                    if (isAuthReady && db && auth) {
                        clearInterval(checkReadyInterval);
                        resolve();
                    }
                }, 100);
            });

            if (!userId) {
                console.log("fetchAndDisplayWatchlist: No userId, showing auth prompt and hiding loading.");
                loadingIndicator.classList.add("hidden");
                authPrompt.classList.remove("hidden");
                if (addManuallyBtn) {
                    addManuallyBtn.disabled = true;
                }
                return;
            } else {
                console.log("fetchAndDisplayWatchlist: userId is present, proceeding to fetch data.");
                if (addManuallyBtn) {
                    addManuallyBtn.disabled = false;
                }
            }

            try {
                const watchlistCollectionRef = collection(
                    db,
                    `artifacts/${appId}/users/${userId}/watchlist`
                );
                // Removed orderBy from here, as sorting is done client-side in applySortAndFilter
                const q = query(watchlistCollectionRef);

                const querySnapshot = await getDocs(q);
                allWatchlistMovies = [];
                querySnapshot.forEach((docSnap) => {
                    allWatchlistMovies.push({ id: docSnap.id, ...docSnap.data() });
                });

                applySortAndFilter(); // This will now handle rendering and noMoviesMessage logic
                watchlistControls.classList.remove("hidden");

            } catch (error) {
                console.error("Error fetching watchlist:", error);
                showMessageBox("Error", `Failed to load watchlist: ${error.message}`);
                noMoviesMessage.classList.remove("hidden");
                watchlistControls.classList.add("hidden");
            } finally {
                loadingIndicator.classList.add("hidden");
                console.log("fetchAndDisplayWatchlist finished.");
            }
        }

        // --- CONSOLIDATED DOMContentLoaded BLOCK ---
        document.addEventListener("DOMContentLoaded", async () => {
            // --- Firebase Initialization ---
            try {
                const initialAuthToken = `<%- __initial_auth_token || 'null' %>`;
                appId = `<%- __app_id || 'default-app-id' %>`;

                if (
                    Object.keys(firebaseConfig).length === 0 ||
                    !firebaseConfig.apiKey ||
                    !firebaseConfig.authDomain
                ) {
                    console.error("Firebase config is empty or missing critical properties (apiKey, authDomain).");
                    showMessageBox("Firebase Error", "Firebase configuration is missing or incomplete. Please check your server setup and .env file.");
                    loadingIndicator.classList.add("hidden");
                    return;
                }

                if (!getApps().length) {
                    app = initializeApp(firebaseConfig);
                    analytics = getAnalytics(app);
                    console.log("Firebase app initialized.");
                } else {
                    app = getApps()[0];
                    analytics = getAnalytics(app);
                    console.log("Firebase app already initialized, retrieving existing app.");
                }

                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Firebase: User signed in:", user.email || "Anonymous", user.uid);
                        authPrompt.classList.add('hidden');
                        watchlistControls.classList.remove('hidden');
                        if (addManuallyBtn) {
                            addManuallyBtn.disabled = false;
                        }
                    } else {
                        userId = null;
                        console.log("Firebase: User signed out. Showing auth prompt.");
                        authPrompt.classList.remove('hidden');
                        watchlistControls.classList.add('hidden');
                        watchlistContent.classList.add('hidden');
                        noMoviesMessage.classList.add('hidden');
                        loadingIndicator.classList.add('hidden');
                        if (addManuallyBtn) {
                            addManuallyBtn.disabled = true;
                        }
                    }
                    isAuthReady = true;
                    console.log("isAuthReady set to true. Calling fetchAndDisplayWatchlist.");
                    fetchAndDisplayWatchlist(); // This is called after auth state is determined
                });

            } catch (error) {
                console.error("Firebase initialization failed:", error);
                showMessageBox("Firebase Error", `Failed to initialize Firebase: ${error.message}. Check your console.`);
                loadingIndicator.classList.add("hidden");
            }

            // --- UI Event Listeners (All consolidated here) ---

            // Message Box Close Button
            if (closeMessageBox) {
                closeMessageBox.addEventListener("click", hideMessageBox);
                console.log("closeMessageBox listener attached.");
            } else {
                console.error("ERROR: closeMessageBox element not found. Check HTML ID.");
            }

            // Manual Add Button
            if (addManuallyBtn) {
                addManuallyBtn.addEventListener("click", () => {
                    manualAddModal.style.display = "block";
                    manualAddMessage.textContent = "";
                    manualAddForm.reset();
                });
                console.log("addManuallyBtn listener attached.");
            } else {
                console.error("ERROR: addManuallyBtn element not found. Check HTML ID.");
            }

            // Manual Add Modal Close Button
            const manualAddModalCloseButton = manualAddModal
                ? manualAddModal.querySelector(".close-button")
                : null;
            if (manualAddModalCloseButton) {
                manualAddModalCloseButton.addEventListener("click", () => {
                    manualAddModal.style.display = "none";
                });
                console.log("manualAddModal close button listener attached.");
            } else {
                console.error("ERROR: close-button inside manualAddModal not found. Check HTML class.");
            }

            // Close the modal when clicking outside of it
            window.addEventListener("click", (event) => {
                if (event.target === manualAddModal) {
                    manualAddModal.style.display = "none";
                }
            });
            console.log("window click listener for manualAddModal attached.");

            // Manual Add Form Submit
            if (manualAddForm) {
                manualAddForm.addEventListener("submit", async (event) => {
                    event.preventDefault();

                    const title = manualMovieName.value.trim();
                    const year = manualMovieYear.value;
                    const overview = manualMovieDescription.value.trim();
                    const status = manualMovieStatus.value;
                    const type = manualMovieType.value;
                    const genreString = manualMovieGenre.value.trim();
                    const genres = genreString ? genreString.split(",").map((g) => g.trim()) : [];

                    if (!title) {
                        manualAddMessage.textContent = "Movie title is required.";
                        manualAddMessage.style.color = "red";
                        return;
                    }

                    const user = auth.currentUser;
                    if (!user) {
                        manualAddMessage.textContent = "You must be logged in to add movies.";
                        manualAddMessage.style.color = "red";
                        return;
                    }
                    const idToken = await user.getIdToken();

                    manualAddMessage.textContent = "Adding movie...";
                    manualAddMessage.style.color = "blue";

                    try {
                        const response = await fetch("/movies/add-manual", {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                Authorization: `Bearer ${idToken}`,
                            },
                            body: JSON.stringify({
                                title,
                                year: year ? parseInt(year, 10) : null,
                                overview,
                                status,
                                type,
                                genres,
                            }),
                        });

                        const result = await response.json();

                        if (response.ok) {
                            manualAddMessage.textContent = result.message || "Movie added successfully!";
                            manualAddMessage.style.color = "green";
                            setTimeout(async () => {
                                manualAddModal.style.display = "none";
                                await fetchAndDisplayWatchlist();
                            }, 500);
                        } else {
                            manualAddMessage.textContent = result.message || "Error adding movie.";
                            manualAddMessage.style.color = "red";
                        }
                    } catch (error) {
                        console.error("Error adding movie manually:", error);
                        manualAddMessage.textContent = "Network error or server unavailable.";
                        manualAddMessage.style.color = "red";
                    }
                });
                console.log("manualAddForm submit listener attached.");
            } else {
                console.error("ERROR: manualAddForm element not found. Check HTML ID.");
            }

            // Sort Dropdown
            const localSortSelect = document.getElementById("sortSelect");
            if (localSortSelect) {
                localSortSelect.addEventListener("change", applySortAndFilter);
                console.log("sortSelect listener attached.");
            } else {
                console.error("ERROR: sortSelect element not found. Check HTML ID.");
            }

            // Filter Status and Type Dropdown
            const localFilterStatusAndTypeSelect = document.getElementById("filterStatusAndTypeSelect");
            if (localFilterStatusAndTypeSelect) {
                localFilterStatusAndTypeSelect.addEventListener("change", applySortAndFilter);
                console.log("filterStatusAndTypeSelect listener attached.");
            } else {
                console.error("ERROR: filterStatusAndTypeSelect element not found. Check HTML ID.");
            }

            // Download List Button Event Listener
            const localDownloadListBtn = document.getElementById("downloadListBtn");
            if (localDownloadListBtn) {
                localDownloadListBtn.addEventListener("click", () => {
                    if (displayedMovies.length === 0) {
                        showMessageBox("No Movies to Download", "Your current filtered list is empty. Add some movies or adjust your filters.");
                        return;
                    }
                    const plainText = generatePlainTextList(displayedMovies);
                    const date = new Date().toISOString().slice(0, 10);
                    const filename = `MyWatchlist_Filtered_${date}.txt`;
                    downloadTextFile(plainText, filename);
                    showMessageBox("Download Started", "Your filtered watchlist is being downloaded.");
                });
                console.log("downloadListBtn listener attached.");
            } else {
                console.error("ERROR: downloadListBtn element not found. Check HTML ID.");
            }

            // Upload List Button Event Listener
            const localUploadListBtn = document.getElementById("uploadListBtn");
            const localFileInput = document.getElementById("fileInput");
            if (localUploadListBtn && localFileInput) {
                localUploadListBtn.addEventListener("click", () => {
                    localFileInput.click();
                });
                localFileInput.addEventListener("change", (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = async (e) => {
                            const textContent = e.target.result;
                            const moviesToUpload = parsePlainTextList(textContent);
                            if (moviesToUpload.length > 0) {
                                await uploadMoviesToWatchlist(moviesToUpload);
                            } else {
                                showMessageBox("No Movies Found", "The uploaded file does not contain any recognizable movie entries.");
                            }
                            localFileInput.value = '';
                        };
                        reader.onerror = () => {
                            showMessageBox("File Read Error", "Could not read the file.");
                        };
                        reader.readAsText(file);
                    }
                });
                console.log("uploadListBtn and fileInput listeners attached.");
            } else {
                console.error("ERROR: uploadListBtn or fileInput element not found. Check HTML IDs.");
            }

            // Bulk Action Buttons
            const localBulkRemoveButton = document.getElementById("bulkRemoveButton");
            if (localBulkRemoveButton) {
                localBulkRemoveButton.addEventListener("click", async () => {
                    if (selectedMovieIds.size === 0) {
                        showMessageBox("No Selection", "Please select movies to remove.");
                        return;
                    }
                    showMessageBox(
                        "Confirm Removal",
                        "Are you sure you want to remove the selected movies from your watchlist?",
                        true,
                        async () => {
                            loadingIndicator.classList.remove("hidden");
                            let removedCount = 0;
                            const currentAppId = appId;
                            const currentUserId = userId;
                            try {
                                for (const movieIdToRemove of selectedMovieIds) {
                                    const movieRef = doc(
                                        db,
                                        `artifacts/${currentAppId}/users/${currentUserId}/watchlist`,
                                        String(movieIdToRemove)
                                    );
                                    await deleteDoc(movieRef);
                                    removedCount++;
                                }
                                showMessageBox("Success", `${removedCount} movie(s) removed from your watchlist.`);
                                selectedMovieIds.clear();
                                await fetchAndDisplayWatchlist();
                            } catch (error) {
                                console.error("Error performing bulk remove:", error);
                                showMessageBox("Error", `Failed to remove movies: ${error.message}`);
                            } finally {
                                loadingIndicator.classList.add("hidden");
                            }
                        }
                    );
                });
                console.log("bulkRemoveButton listener attached.");
            } else {
                console.error("ERROR: bulkRemoveButton element not found. Check HTML ID.");
            }

            const localApplyBulkStatusButton = document.getElementById("applyBulkStatusButton");
            if (localApplyBulkStatusButton) {
                localApplyBulkStatusButton.addEventListener("click", async () => {
                    const newStatus = bulkStatusSelect.value;
                    if (selectedMovieIds.size === 0) {
                        showMessageBox("No Selection", "Please select movies to update.");
                        return;
                    }
                    if (!newStatus) {
                        showMessageBox("No Status Selected", "Please select a new status from the dropdown.");
                        return;
                    }

                    loadingIndicator.classList.remove("hidden");
                    let updatedCount = 0;
                    const currentAppId = appId;
                    const currentUserId = userId;

                    try {
                        for (const movieIdToUpdate of selectedMovieIds) {
                            const movieRef = doc(
                                db,
                                `artifacts/${currentAppId}/users/${currentUserId}/watchlist`,
                                String(movieIdToUpdate)
                            );
                            await updateDoc(movieRef, {
                                status: newStatus,
                                updated_at: Timestamp.now(),
                            });
                            updatedCount++;
                        }
                        showMessageBox("Success", `${updatedCount} movie(s) status updated to "${newStatus}".`);
                        selectedMovieIds.clear();
                        bulkStatusSelect.value = "";
                        await fetchAndDisplayWatchlist();
                    } catch (error) {
                        console.error("Error performing bulk status update:", error);
                        showMessageBox("Error", `Failed to update movie status: ${error.message}`);
                    } finally {
                        loadingIndicator.classList.add("hidden");
                    }
                });
                console.log("applyBulkStatusButton listener attached.");
            } else {
                console.error("ERROR: applyBulkStatusButton element not found. Check HTML ID.");
            }
        }); // End of CONSOLIDATED DOMContentLoaded
    </script>
  </body>
</html>
