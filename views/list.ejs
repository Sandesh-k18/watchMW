<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>My Watchlist</title>
    <link href="/list.css" rel="stylesheet" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />

  </head>
  <body>
    <nav class="navbar">
      <div class="nav-container">
        <a href="/" class="nav-link">Home</a>
        <a href="/search" class="nav-link">Search Movies</a>
        <a href="/user/list" class="nav-link">My Watchlist</a>
        <a href="/about" class="nav-link">About</a>
        <a href="/contact" class="nav-link">Contact</a>
        <a href="/faq" class="nav-link">FAQ</a>
        <a href="/user/profile" class="nav-link">Profile</a>
      </div>
    </nav>

    <div class="container">
      <h1>My Watchlist</h1>

      <div id="loadingIndicator" class="loading-indicator">
        Loading your watchlist...
      </div>

      <div id="authPrompt" class="auth-prompt hidden">
        <h2>Unlock Your Personalized Watchlist!</h2>
        <p>
          Sign up or log in to save your favorite movies and access them
          anytime, anywhere.
        </p>
        <div class="auth-links">
          <a href="/register">Sign Up</a>
          <a href="/login">Log In</a>
        </div>
      </div>

      <div id="watchlistControls" class="watchlist-controls hidden">
        <select id="sortSelect">
          <option value="added_at_desc">Date Added (Newest First)</option>
          <option value="added_at_asc">Date Added (Oldest First)</option>
          <option value="release_date_desc">Release Date (Newest First)</option>
          <option value="release_date_asc">Release Date (Oldest First)</option>
          <option value="title_asc">Title (A-Z)</option>
          <option value="title_desc">Title (Z-A)</option>
          <option value="type_asc">Type (A-Z)</option>
          <option value="type_desc">Type (Z-A)</option>
          <option value="genre_asc">Genre (A-Z)</option>
          <option value="genre_desc">Genre (Z-A)</option>
        </select>

        <button
          id="addManuallyBtn"
          class="btn btn-primary"
          style="margin-left: 10px"
        >
          Add Manually
        </button>
        <button
          id="addBySearchBtn"
          class="btn btn-primary"  
          style="margin-left: 10px"
        >
          <a
            href="/search"
            style="
              text-decoration: none;
              color: inherit;
              display: block;
              padding: 0;
            "
            >Add By Search</a
          >
        </button>

        <select id="bulkStatusSelect" class="hidden">
          <option value="">Change Status Of Selected To...</option>
          <option value="Plan to Watch">Plan to Watch</option>
          <option value="Watching">Watching</option>
          <option value="Completed">Completed</option>
          <option value="Dropped">Dropped</option>
        </select>
        <button id="applyBulkStatusButton" class="hidden">Apply Status</button>
        <button id="bulkRemoveButton" class="remove-button hidden">
          Remove Selected
        </button>
      </div>

      <div id="watchlistContent" class="movie-list-container hidden"></div>

      <div id="noMoviesMessage" class="no-content-message hidden">
        Your watchlist is empty! Start adding movies from the
        <a href="/search">Search Movies</a> page.
      </div>
    </div>

    <div id="messageBox" class="message-box hidden">
      <div class="header">
        <h3 id="messageTitle"></h3>
        <button id="closeMessageBox" class="close-button">&times;</button>
      </div>
      <p id="messageContent"></p>
    </div>

    <div
      id="manualAddModal"
      class="modal"
      style="
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.4);
      "
    >
      <div
        class="modal-content"
        style="
          background-color: #fefefe;
          margin: 15% auto;
          padding: 20px;
          border: 1px solid #888;
          width: 80%;
          max-width: 500px;
          border-radius: 8px;
          position: relative;
        "
      >
        <span
          class="close-button"
          style="
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
          "
          >&times;</span
        >
        <h2>Add Movie Manually</h2>
        <form id="manualAddForm">
          <div class="form-group" style="margin-bottom: 15px">
            <label
              for="manualMovieName"
              style="display: block; margin-bottom: 5px"
              >Movie Name:</label
            >
            <input
              type="text"
              id="manualMovieName"
              name="title"
              required
              class="form-control"
              style="
                width: 100%;
                padding: 8px;
                box-sizing: border-box;
                border: 1px solid #ccc;
                border-radius: 4px;
              "
            />
          </div>
          <div class="form-group" style="margin-bottom: 15px">
            <label
              for="manualMovieYear"
              style="display: block; margin-bottom: 5px"
              >Year (Optional):</label
            >
            <input
              type="number"
              id="manualMovieYear"
              name="year"
              min="1800"
              max="<%= new Date().getFullYear() + 5 %>"
              class="form-control"
              style="
                width: 100%;
                padding: 8px;
                box-sizing: border-box;
                border: 1px solid #ccc;
                border-radius: 4px;
              "
            />
          </div>
          <button
            type="submit"
            class="btn btn-success"
            style="
              padding: 10px 15px;
              border: none;
              border-radius: 5px;
              background-color: #28a745;
              color: white;
              cursor: pointer;
            "
          >
            Add Movie
          </button>
          <p id="manualAddMessage" style="margin-top: 10px; color: green"></p>
        </form>
      </div>
    </div>

    <script type="module">
      // Import Firebase services
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
      import {
        getAuth,
        signInAnonymously,
        signInWithCustomToken,
        onAuthStateChanged,
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
      import {
        getFirestore,
        doc,
        getDoc,
        setDoc,
        collection,
        query,
        where,
        addDoc,
        getDocs,
        deleteDoc,
        onSnapshot,
        updateDoc,
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

      // Module-scoped variables for Firebase instances and user state
      let app;
      let db;
      let auth;
      let userId = null;
      let isAuthReady = false;
      let appId = "default-app-id"; // Default, will be updated from EJS local variable

      let allWatchlistMovies = []; // Stores the full list of movies fetched from Firestore
      let selectedMovieIds = new Set(); // Stores IDs of selected movies for bulk actions

      // DOM elements
      const loadingIndicator = document.getElementById("loadingIndicator");
      const authPrompt = document.getElementById("authPrompt");
      // IMPORTANT: watchlistContent now refers to the main movie grid container
      const watchlistContent = document.getElementById("watchlistContent");
      const noMoviesMessage = document.getElementById("noMoviesMessage");
      const messageBox = document.getElementById("messageBox");
      const messageTitle = document.getElementById("messageTitle");
      const messageContent = document.getElementById("messageContent");
      const closeMessageBox = document.getElementById("closeMessageBox"); // Corrected ID

      const watchlistControls = document.getElementById("watchlistControls");
      const sortSelect = document.getElementById("sortSelect");
      const bulkStatusSelect = document.getElementById("bulkStatusSelect");
      const applyBulkStatusButton = document.getElementById(
        "applyBulkStatusButton"
      );
      const bulkRemoveButton = document.getElementById("bulkRemoveButton");

      // Manual Add Modal DOM elements
      const addManuallyBtn = document.getElementById("addManuallyBtn");
      const manualAddModal = document.getElementById("manualAddModal");
      // const closeButton = manualAddModal.querySelector('.close-button'); // This was redundant, use closeMessageBox
      const manualAddForm = document.getElementById("manualAddForm");
      const manualAddMessage = document.getElementById("manualAddMessage");

      // Function to show a custom message box
      function showMessageBox(title, message) {
        if (messageBox && messageTitle && messageContent) {
          messageTitle.textContent = title;
          messageContent.textContent = message;
          messageBox.classList.add("show"); // Assuming 'show' class makes it visible
        } else {
          console.error("Message box elements not found:", title, message);
        }
      }

      // Function to hide the custom message box
      function hideMessageBox() {
        if (messageBox) {
          messageBox.classList.remove("show");
        }
      }

      // Attach hideMessageBox to the close button
      if (closeMessageBox) {
        // Use the corrected ID
        closeMessageBox.addEventListener("click", hideMessageBox);
      }

      // Function to update visibility of bulk action buttons
      function updateBulkActionVisibility() {
        if (selectedMovieIds.size > 0) {
          bulkStatusSelect.classList.remove("hidden");
          applyBulkStatusButton.classList.remove("hidden");
          bulkRemoveButton.classList.remove("hidden");
        } else {
          bulkStatusSelect.classList.add("hidden");
          applyBulkStatusButton.classList.add("hidden");
          bulkRemoveButton.classList.add("hidden");
          bulkStatusSelect.value = ""; // Reset dropdown
        }
      }

      // Function to render movie cards
      function renderWatchlistMovies(moviesToRender) {
        watchlistContent.innerHTML = ""; // Clear current display
        if (moviesToRender.length === 0) {
          noMoviesMessage.classList.remove("hidden");
          watchlistControls.classList.add("hidden"); // Hide controls if no movies
          watchlistContent.classList.add("hidden"); // Ensure content area is hidden
          return;
        }

        noMoviesMessage.classList.add("hidden");
        watchlistControls.classList.remove("hidden"); // Show controls if movies exist
        watchlistContent.classList.remove("hidden"); // Show content area

        moviesToRender.forEach((movie) => {
          const movieCard = document.createElement("div");
          movieCard.classList.add("movie-card");
          // Add 'selected' class if movie is currently selected
          if (selectedMovieIds.has(movie.id)) {
            movieCard.classList.add("selected");
          }

          // Checkbox for selection
          const checkboxContainer = document.createElement("div");
          checkboxContainer.classList.add("checkbox-container");
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.value = movie.id;
          checkbox.checked = selectedMovieIds.has(movie.id); // Set initial checked state
          checkbox.addEventListener("change", (event) => {
            if (event.target.checked) {
              selectedMovieIds.add(movie.id);
              movieCard.classList.add("selected");
            } else {
              selectedMovieIds.delete(movie.id);
              movieCard.classList.remove("selected");
            }
            updateBulkActionVisibility();
          });
          checkboxContainer.appendChild(checkbox);
          movieCard.appendChild(checkboxContainer);

          // Status Badge
          const statusBadge = document.createElement("span");
          statusBadge.classList.add("status-badge");
          // Add specific class for styling based on status
          statusBadge.classList.add(
            movie.status
              ? movie.status.toLowerCase().replace(/\s/g, "-")
              : "plan-to-watch"
          );
          statusBadge.textContent = movie.status || "Plan to Watch";
          movieCard.appendChild(statusBadge);

          const cardLink = document.createElement("a");
          cardLink.href = `/movie/${movie.id}`; // Link to movie details page
          cardLink.classList.add("card-link");
          cardLink.style.textDecoration = "none";
          cardLink.style.color = "inherit";
          cardLink.style.display = "block";
          cardLink.style.height = "100%";

          const poster = document.createElement("img");
          poster.alt = movie.title;
          poster.classList.add("poster-image");

          // --- Poster Logic (Updated) ---
          if (movie.isManual) {
            poster.src = "/images/default.png"; // Use your actual default logo path
            poster.classList.add("custom-manual-poster"); // Add specific class for styling
          } else if (movie.poster_path) {
            poster.src = `https://image.tmdb.org/t/p/w500${movie.poster_path}`;
          } else {
            poster.src = "/images/default.png"; // Fallback for TMDB movies with no poster
          }
          // --- End Poster Logic ---

          const movieInfoSummary = document.createElement("div");
          movieInfoSummary.classList.add("movie-info-summary");

          const titleElement = document.createElement("h2");
          titleElement.textContent = movie.title;

          // Improved year display logic
          const displayYear = movie.year
            ? movie.year
            : movie.release_date
            ? new Date(movie.release_date).getFullYear()
            : "N/A";
          const releaseYearElement = document.createElement("p");
          releaseYearElement.classList.add("release-year");
          releaseYearElement.textContent = `Year: ${displayYear}`;

          const overviewOverlay = document.createElement("div");
          overviewOverlay.classList.add("movie-overview-overlay");
          const overviewText = document.createElement("p");
          overviewText.textContent =
            movie.overview || "No description available.";
          overviewOverlay.appendChild(overviewText);

          movieInfoSummary.appendChild(titleElement);
          movieInfoSummary.appendChild(releaseYearElement);

          cardLink.appendChild(poster);
          cardLink.appendChild(movieInfoSummary);
          cardLink.appendChild(overviewOverlay);

          movieCard.appendChild(cardLink);
          watchlistContent.appendChild(movieCard);
        });
        updateBulkActionVisibility(); // Update visibility after rendering
      }

      // Function to sort movies
      function sortMovies(movies, sortBy) {
        return [...movies].sort((a, b) => {
          let valA, valB;

          switch (sortBy) {
            case "added_at_desc":
              valA = a.added_at ? a.added_at.toDate() : new Date(0); // Convert Firestore Timestamp to Date
              valB = b.added_at ? b.added_at.toDate() : new Date(0);
              return valB.getTime() - valA.getTime();
            case "added_at_asc":
              valA = a.added_at ? a.added_at.toDate() : new Date(0);
              valB = b.added_at ? b.added_at.toDate() : new Date(0);
              return valA.getTime() - valB.getTime();
            case "release_date_desc":
              // Prioritize 'year' for manual entries, otherwise use release_date
              valA = a.year
                ? a.year
                : a.release_date
                ? new Date(a.release_date).getFullYear()
                : 0;
              valB = b.year
                ? b.year
                : b.release_date
                ? new Date(b.release_date).getFullYear()
                : 0;
              return valB - valA;
            case "release_date_asc":
              valA = a.year
                ? a.year
                : a.release_date
                ? new Date(a.release_date).getFullYear()
                : 0;
              valB = b.year
                ? b.year
                : b.release_date
                ? new Date(b.release_date).getFullYear()
                : 0;
              return valA - valB;
            case "title_asc":
              valA = a.title.toLowerCase();
              valB = b.title.toLowerCase();
              return valA.localeCompare(valB);
            case "title_desc":
              valA = a.title.toLowerCase();
              valB = b.title.toLowerCase();
              return valB.localeCompare(valA);
            case "type_asc":
              valA = (a.type || "movie").toLowerCase();
              valB = (b.type || "movie").toLowerCase();
              return valA.localeCompare(valB);
            case "type_desc":
              valA = (a.type || "movie").toLowerCase();
              valB = (b.type || "movie").toLowerCase();
              return valB.localeCompare(valA);
            case "genre_asc":
              // Assuming 'genre' is an array of strings, sort by first genre or a default
              valA = (
                a.genre && a.genre.length > 0 ? a.genre[0] : "z"
              ).toLowerCase();
              valB = (
                b.genre && b.genre.length > 0 ? b.genre[0] : "z"
              ).toLowerCase();
              return valA.localeCompare(valB);
            case "genre_desc":
              valA = (
                a.genre && a.genre.length > 0 ? a.genre[0] : "a"
              ).toLowerCase();
              valB = (
                b.genre && b.genre.length > 0 ? b.genre[0] : "a"
              ).toLowerCase();
              return valB.localeCompare(valA);
            default:
              return 0; // No sort
          }
        });
      }

      // Event listener for sorting dropdown
      sortSelect.addEventListener("change", () => {
        const sortedMovies = sortMovies(allWatchlistMovies, sortSelect.value);
        renderWatchlistMovies(sortedMovies);
      });

      // Bulk Remove Function
      bulkRemoveButton.addEventListener("click", async () => {
        if (selectedMovieIds.size === 0) {
          showMessageBox("No Selection", "Please select movies to remove.");
          return;
        }

        if (
          !confirm(
            "Are you sure you want to remove the selected movies from your watchlist?"
          )
        ) {
          return; // User cancelled
        }

        loadingIndicator.classList.remove("hidden");
        let removedCount = 0;
        const dbRef = db; // Use module-scoped db
        const currentAppId = appId; // Use module-scoped appId
        const currentUserId = userId; // Use module-scoped userId

        try {
          for (const movieIdToRemove of selectedMovieIds) {
            const movieRef = doc(
              dbRef,
              `artifacts/${currentAppId}/users/${currentUserId}/watchlist`,
              String(movieIdToRemove)
            );
            await deleteDoc(movieRef);
            removedCount++;
          }
          showMessageBox(
            "Success",
            `${removedCount} movie(s) removed from your watchlist.`
          );
          selectedMovieIds.clear(); // Clear selection
          await fetchAndDisplayWatchlist(); // Re-fetch and re-render
        } catch (error) {
          console.error("Error performing bulk remove:", error);
          showMessageBox("Error", `Failed to remove movies: ${error.message}`);
        } finally {
          loadingIndicator.classList.add("hidden");
        }
      });

      // Bulk Change Status Function
      applyBulkStatusButton.addEventListener("click", async () => {
        const newStatus = bulkStatusSelect.value;
        if (selectedMovieIds.size === 0) {
          showMessageBox("No Selection", "Please select movies to update.");
          return;
        }
        if (!newStatus) {
          showMessageBox(
            "No Status Selected",
            "Please select a new status from the dropdown."
          );
          return;
        }

        loadingIndicator.classList.remove("hidden");
        let updatedCount = 0;
        const dbRef = db; // Use module-scoped db
        const currentAppId = appId; // Use module-scoped appId
        const currentUserId = userId; // Use module-scoped userId

        try {
          for (const movieIdToUpdate of selectedMovieIds) {
            const movieRef = doc(
              dbRef,
              `artifacts/${currentAppId}/users/${currentUserId}/watchlist`,
              String(movieIdToUpdate)
            );
            await updateDoc(movieRef, {
              status: newStatus,
              updated_at: new Date(),
            });
            updatedCount++;
          }
          showMessageBox(
            "Success",
            `${updatedCount} movie(s) status updated to "${newStatus}".`
          );
          selectedMovieIds.clear(); // Clear selection
          bulkStatusSelect.value = ""; // Reset dropdown
          await fetchAndDisplayWatchlist(); // Re-fetch and re-render
        } catch (error) {
          console.error("Error performing bulk status update:", error);
          showMessageBox(
            "Error",
            `Failed to update movie status: ${error.message}`
          );
        } finally {
          loadingIndicator.classList.add("hidden");
        }
      });

      // Function to fetch and display watchlist
      async function fetchAndDisplayWatchlist() {
        loadingIndicator.classList.remove("hidden");
        authPrompt.classList.add("hidden");
        watchlistContent.classList.add("hidden");
        noMoviesMessage.classList.add("hidden");
        watchlistControls.classList.add("hidden"); // Hide controls initially
        watchlistContent.innerHTML = ""; // Clear previous content
        selectedMovieIds.clear(); // Clear any existing selections
        updateBulkActionVisibility(); // Hide bulk actions

        // Wait until Firebase Auth and Firestore are initialized and ready
        await new Promise((resolve) => {
          const checkReadyInterval = setInterval(() => {
            if (isAuthReady && db) {
              // Ensure db is initialized
              clearInterval(checkReadyInterval);
              resolve();
            }
          }, 100);
        });

        if (!userId) {
          // If user is not logged in
          loadingIndicator.classList.add("hidden");
          authPrompt.classList.remove("hidden");
          return;
        }

        try {
          const watchlistCollectionRef = collection(
            db,
            `artifacts/${appId}/users/${userId}/watchlist`
          );
          const q = query(watchlistCollectionRef);

          const querySnapshot = await getDocs(q);
          allWatchlistMovies = []; // Reset the global array
          querySnapshot.forEach((docSnap) => {
            allWatchlistMovies.push(docSnap.data());
          });

          if (allWatchlistMovies.length > 0) {
            const currentSort = sortSelect.value;
            const sortedMovies = sortMovies(allWatchlistMovies, currentSort);
            renderWatchlistMovies(sortedMovies);
          } else {
            noMoviesMessage.classList.remove("hidden");
          }
        } catch (error) {
          console.error("Error fetching watchlist:", error);
          showMessageBox("Error", `Failed to load watchlist: ${error.message}`);
          noMoviesMessage.classList.remove("hidden"); // Show empty message on error as well
        } finally {
          loadingIndicator.classList.add("hidden");
        }
      }

      // Initialize Firebase and set up authentication
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          // Get Firebase config and Canvas globals from EJS local variables
          const firebaseConfig = JSON.parse(`<%- firebaseConfig %>`);
          const initialAuthToken = `<%- __initial_auth_token %>`;
          appId = `<%- __app_id %>`; // Assign to module-scoped appId

          if (
            Object.keys(firebaseConfig).length === 0 ||
            !firebaseConfig.apiKey ||
            !firebaseConfig.authDomain
          ) {
            console.error(
              "Firebase config is empty or missing critical properties (apiKey, authDomain)."
            );
            showMessageBox(
              "Firebase Error",
              "Firebase configuration is missing or incomplete. Please check your server setup and .env file."
            );
            return;
          }

          app = initializeApp(firebaseConfig);
          db = getFirestore(app); // Assign to module-scoped db
          auth = getAuth(app); // Assign to module-scoped auth

          onAuthStateChanged(auth, async (user) => {
            if (user) {
              userId = user.uid; // Assign to module-scoped userId
              console.log("Firebase: User signed in:", userId);
            } else {
              userId = null; // Assign to module-scoped userId
              console.log("Firebase: User signed out.");
            }
            isAuthReady = true; // Auth state has been determined
            fetchAndDisplayWatchlist(); // Call after auth state is determined
          });

          if (initialAuthToken && initialAuthToken !== "null") {
            await signInWithCustomToken(auth, initialAuthToken);
            console.log("Firebase: Signed in with custom token.");
          } else {
            await signInAnonymously(auth);
            console.log("Firebase: Signed in anonymously.");
          }
        } catch (error) {
          console.error("Firebase initialization failed:", error);
          showMessageBox(
            "Firebase Error",
            `Failed to initialize Firebase: ${error.message}. Check your console.`
          );
        }
      });

      // Manual Add Modal / Form Logic
      document.addEventListener("DOMContentLoaded", () => {
        // Open the modal
        if (addManuallyBtn) {
          addManuallyBtn.addEventListener("click", () => {
            manualAddModal.style.display = "block";
            manualAddMessage.textContent = ""; // Clear previous messages
            manualAddForm.reset(); // Clear form fields
          });
        }

        // Close the modal when the 'x' is clicked
        if (closeMessageBox) {
          // Use the close button specific to the modal
          manualAddModal
            .querySelector(".close-button")
            .addEventListener("click", () => {
              manualAddModal.style.display = "none";
            });
        }

        // Close the modal when clicking outside of it
        window.addEventListener("click", (event) => {
          if (event.target === manualAddModal) {
            manualAddModal.style.display = "none";
          }
        });

        // Handle form submission for manual add
        if (manualAddForm) {
          manualAddForm.addEventListener("submit", async (event) => {
            event.preventDefault(); // Prevent default form submission

            const title = document
              .getElementById("manualMovieName")
              .value.trim();
            const year = document.getElementById("manualMovieYear").value;

            if (!title) {
              manualAddMessage.textContent = "Movie name is required.";
              manualAddMessage.style.color = "red";
              return;
            }

            const movieData = {
              title: title,
              year: year ? parseInt(year, 10) : null, // Convert year to number, or null if empty
            };

            try {
              // Send data to your backend
              const response = await fetch("/movies/add-manual", {
                // <-- This is your new backend route
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify(movieData),
              });

              const result = await response.json();

              if (response.ok) {
                manualAddMessage.textContent =
                  result.message || "Movie added successfully!";
                manualAddMessage.style.color = "green";
                // Immediately re-fetch and re-display the watchlist to show the new movie
                setTimeout(async () => {
                  manualAddModal.style.display = "none";
                  await fetchAndDisplayWatchlist(); // Call the main fetch function
                }, 500); // Give a little time for message to be read
              } else {
                manualAddMessage.textContent =
                  result.message || "Error adding movie.";
                manualAddMessage.style.color = "red";
              }
            } catch (error) {
              console.error("Error adding movie manually:", error);
              manualAddMessage.textContent =
                "Network error or server unavailable.";
              manualAddMessage.style.color = "red";
            }
          });
        }
      });
    </script>
  </body>
</html>
